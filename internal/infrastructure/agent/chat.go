package agent

import (
	"context"
	"fmt"
	"log"

	"github.com/google/uuid"
	domainAgent "github.com/mololab/alodb/internal/domain/agent"
	"github.com/mololab/alodb/internal/infrastructure/agent/response"

	"google.golang.org/adk/agent"
	"google.golang.org/adk/session"
	"google.golang.org/genai"
)

// Chat processes a chat request and returns a response
func (a *DBAgent) Chat(ctx context.Context, req domainAgent.ChatRequest) (*domainAgent.ChatResponse, error) {
	log.Printf("[CHAT] Processing request: message=%s", req.Message)
	log.Printf("[CHAT] Connection string provided: %v", req.ConnectionString != "")

	sessionID, err := a.getOrCreateSession(ctx, req.SessionID)
	if err != nil {
		return nil, fmt.Errorf("failed to manage session: %w", err)
	}

	ctx = a.storeSecureContext(ctx, req.ConnectionString)

	// run the agent
	responseText, err := a.runAgentToCompletion(ctx, sessionID, req.Message)
	if err != nil {
		return nil, fmt.Errorf("agent execution failed: %w", err)
	}

	log.Printf("[CHAT] Final response: %s", responseText)

	// parse the response
	parser := response.NewParser()
	return parser.Parse(sessionID, responseText)
}

// getOrCreateSession returns existing session ID or creates a new one
func (a *DBAgent) getOrCreateSession(ctx context.Context, existingID string) (string, error) {
	if existingID != "" {
		log.Printf("[CHAT] Continuing session: %s", existingID)
		if err := a.ensureSession(ctx, existingID); err != nil {
			return "", err
		}
		return existingID, nil
	}

	newID := uuid.New().String()
	log.Printf("[CHAT] New session created: %s", newID)
	if err := a.ensureSession(ctx, newID); err != nil {
		return "", err
	}
	return newID, nil
}

// storeSecureContext adds secure data to context (connection string, cache TTL)
func (a *DBAgent) storeSecureContext(ctx context.Context, connStr string) context.Context {
	if connStr != "" {
		ctx = context.WithValue(ctx, connectionStringKey, connStr)
		log.Printf("[CHAT] Connection string stored in context")
	}

	// store schema cache TTL
	ctx = context.WithValue(ctx, schemaCacheTTLKey, a.schemaCacheTTL)

	return ctx
}

// runAgentToCompletion runs the agent and waits for the final response after all tool calls
func (a *DBAgent) runAgentToCompletion(ctx context.Context, sessionID, message string) (string, error) {
	content := genai.NewContentFromText(message, genai.RoleUser)
	log.Printf("[CHAT] Running agent...")

	events := a.runner.Run(ctx, sessionID, sessionID, content, agent.RunConfig{})

	var finalResponse string
	var lastModelResponse string
	eventCount := 0

	for event, err := range events {
		eventCount++
		if err != nil {
			log.Printf("[CHAT] Error during agent execution: %v", err)
			return "", fmt.Errorf("agent execution error: %w", err)
		}

		logEvent(event, eventCount)

		// we want the last text response from the model
		// this comes after all tool calls have been processed
		if event.Content != nil && event.Content.Role == string(genai.RoleModel) {
			text := ExtractTextFromEvent(event)
			if text != "" {
				lastModelResponse = text
				log.Printf("[CHAT] Captured model response: %s", truncateForLog(text, 100))
			}
		}
	}

	finalResponse = lastModelResponse

	if finalResponse == "" {
		log.Printf("[CHAT] Warning: No response text captured from %d events", eventCount)
		return "", fmt.Errorf("no response generated by agent")
	}

	log.Printf("[CHAT] Agent completed with %d events", eventCount)
	return finalResponse, nil
}

// logEvent logs event details for debugging
func logEvent(event *session.Event, count int) {
	if event == nil || event.Content == nil {
		return
	}

	hasText := false
	hasFunctionCall := false
	hasFunctionResponse := false
	functionName := ""

	for _, part := range event.Content.Parts {
		if part.Text != "" {
			hasText = true
		}
		if part.FunctionCall != nil {
			hasFunctionCall = true
			functionName = part.FunctionCall.Name
		}
		if part.FunctionResponse != nil {
			hasFunctionResponse = true
			functionName = part.FunctionResponse.Name
		}
	}

	log.Printf("[EVENT #%d] author=%s role=%s hasText=%v hasFuncCall=%v hasFuncResp=%v func=%s",
		count, event.Author, event.Content.Role, hasText, hasFunctionCall, hasFunctionResponse, functionName)
}

// truncateForLog truncates a string for logging purposes
func truncateForLog(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}

// ensureSession creates a session if it doesn't exist
func (a *DBAgent) ensureSession(ctx context.Context, sessionID string) error {
	_, err := a.sessionService.Get(ctx, &session.GetRequest{
		AppName:   agentName,
		UserID:    sessionID,
		SessionID: sessionID,
	})
	if err == nil {
		return nil // session exists
	}

	// create new session
	_, err = a.sessionService.Create(ctx, &session.CreateRequest{
		AppName:   agentName,
		UserID:    sessionID,
		SessionID: sessionID,
	})
	if err != nil {
		return fmt.Errorf("failed to create session: %w", err)
	}

	return nil
}
